"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SymbolTable = exports.ArrayType = exports.ClassSymbol = exports.FieldSymbol = exports.MethodSymbol = exports.MethodFlags = exports.RoutineSymbol = exports.ParameterSymbol = exports.LiteralSymbol = exports.VariableSymbol = exports.BlockSymbol = exports.NamespaceSymbol = exports.ScopedSymbol = exports.TypeAlias = exports.TypedSymbol = exports.Symbol = exports.FundamentalType = exports.ReferenceKind = exports.TypeKind = exports.MemberVisibility = exports.DuplicateSymbolError = void 0;
class DuplicateSymbolError extends Error {
}
exports.DuplicateSymbolError = DuplicateSymbolError;
var MemberVisibility;
(function (MemberVisibility) {
    MemberVisibility[MemberVisibility["Invalid"] = -1] = "Invalid";
    MemberVisibility[MemberVisibility["Public"] = 0] = "Public";
    MemberVisibility[MemberVisibility["Protected"] = 1] = "Protected";
    MemberVisibility[MemberVisibility["Private"] = 2] = "Private";
    MemberVisibility[MemberVisibility["Library"] = 3] = "Library";
})(MemberVisibility = exports.MemberVisibility || (exports.MemberVisibility = {}));
var TypeKind;
(function (TypeKind) {
    TypeKind[TypeKind["Integer"] = 0] = "Integer";
    TypeKind[TypeKind["Float"] = 1] = "Float";
    TypeKind[TypeKind["String"] = 2] = "String";
    TypeKind[TypeKind["Boolean"] = 3] = "Boolean";
    TypeKind[TypeKind["Date"] = 4] = "Date";
    TypeKind[TypeKind["Class"] = 5] = "Class";
    TypeKind[TypeKind["Array"] = 6] = "Array";
    TypeKind[TypeKind["Alias"] = 7] = "Alias";
})(TypeKind = exports.TypeKind || (exports.TypeKind = {}));
var ReferenceKind;
(function (ReferenceKind) {
    ReferenceKind[ReferenceKind["Irrelevant"] = 0] = "Irrelevant";
    ReferenceKind[ReferenceKind["Pointer"] = 1] = "Pointer";
    ReferenceKind[ReferenceKind["Reference"] = 2] = "Reference";
    ReferenceKind[ReferenceKind["Instance"] = 3] = "Instance";
})(ReferenceKind = exports.ReferenceKind || (exports.ReferenceKind = {}));
class FundamentalType {
    constructor(name, typeKind, referenceKind) {
        this.name = name;
        this.typeKind = typeKind;
        this.referenceKind = referenceKind;
    }
    get baseTypes() {
        return [];
    }
    get kind() {
        return this.typeKind;
    }
    get reference() {
        return this.referenceKind;
    }
}
exports.FundamentalType = FundamentalType;
FundamentalType.integerType = new FundamentalType("int", TypeKind.Integer, ReferenceKind.Instance);
FundamentalType.floatType = new FundamentalType("float", TypeKind.Float, ReferenceKind.Instance);
FundamentalType.stringType = new FundamentalType("string", TypeKind.String, ReferenceKind.Instance);
FundamentalType.boolType = new FundamentalType("bool", TypeKind.Boolean, ReferenceKind.Instance);
FundamentalType.dateType = new FundamentalType("date", TypeKind.Date, ReferenceKind.Instance);
class Symbol {
    constructor(name = "") {
        this.name = "";
        this.name = name;
    }
    setParent(parent) {
        this.theParent = parent;
    }
    get parent() {
        return this.theParent;
    }
    get firstSibling() {
        if (this.theParent instanceof ScopedSymbol) {
            return this.theParent.firstChild;
        }
        return this;
    }
    get previousSibling() {
        if (!(this.theParent instanceof ScopedSymbol)) {
            return this;
        }
        return this.theParent.previousSiblingOf(this);
    }
    get nextSibling() {
        if (!(this.theParent instanceof ScopedSymbol)) {
            return this;
        }
        return this.theParent.nextSiblingOf(this);
    }
    get lastSibling() {
        if (this.theParent instanceof ScopedSymbol) {
            return this.theParent.lastChild;
        }
        return this;
    }
    get next() {
        if (this.theParent instanceof ScopedSymbol) {
            return this.theParent.nextOf(this);
        }
        return undefined;
    }
    removeFromParent() {
        if (this.theParent instanceof ScopedSymbol) {
            this.theParent.removeSymbol(this);
            this.theParent = undefined;
        }
    }
    resolve(name, localOnly = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.theParent instanceof ScopedSymbol) {
                return this.theParent.resolve(name, localOnly);
            }
            return Promise.resolve(undefined);
        });
    }
    get root() {
        let run = this.theParent;
        while (run) {
            if (!run.theParent || (run.theParent instanceof SymbolTable)) {
                return run;
            }
            run = run.theParent;
        }
        return run;
    }
    get symbolTable() {
        if (this instanceof SymbolTable) {
            return this;
        }
        let run = this.theParent;
        while (run) {
            if (run instanceof SymbolTable) {
                return run;
            }
            run = run.theParent;
        }
        return undefined;
    }
    getParentOfType(t) {
        let run = this.theParent;
        while (run) {
            if (run instanceof t) {
                return run;
            }
            run = run.theParent;
        }
        return undefined;
    }
    get symbolPath() {
        const result = [];
        let run = this;
        while (run) {
            result.push(run);
            if (!run.theParent) {
                break;
            }
            run = run.theParent;
        }
        return result;
    }
    qualifiedName(separator = ".", full = false, includeAnonymous = false) {
        if (!includeAnonymous && this.name.length === 0) {
            return "";
        }
        let result = this.name.length === 0 ? "<anonymous>" : this.name;
        let run = this.theParent;
        while (run) {
            if (includeAnonymous || run.name.length > 0) {
                result = (run.name.length === 0 ? "<anonymous>" : run.name) + separator + result;
            }
            if (!full || !run.theParent) {
                break;
            }
            run = run.theParent;
        }
        return result;
    }
}
exports.Symbol = Symbol;
class TypedSymbol extends Symbol {
    constructor(name, type) {
        super(name);
        this.type = type;
    }
}
exports.TypedSymbol = TypedSymbol;
class TypeAlias extends Symbol {
    constructor(name, target) {
        super(name);
        this.targetType = target;
    }
    get baseTypes() { return [this.targetType]; }
    get kind() { return TypeKind.Alias; }
    get reference() { return ReferenceKind.Irrelevant; }
}
exports.TypeAlias = TypeAlias;
class ScopedSymbol extends Symbol {
    constructor(name = "") {
        super(name);
        this._children = [];
    }
    get children() {
        return this._children;
    }
    clear() {
        this._children = [];
    }
    addSymbol(symbol) {
        symbol.removeFromParent();
        const symbolTable = this.symbolTable;
        if (!symbolTable || !symbolTable.options.allowDuplicateSymbols) {
            this.children.forEach((child) => {
                if (child === symbol || (symbol.name.length > 0 && child.name === symbol.name)) {
                    let name = symbol.name;
                    if (name.length === 0) {
                        name = "<anonymous>";
                    }
                    throw new DuplicateSymbolError("Attempt to add duplicate symbol '" + name + "'");
                }
            });
        }
        this.children.push(symbol);
        symbol.setParent(this);
    }
    removeSymbol(symbol) {
        const index = this.children.indexOf(symbol);
        if (index > -1) {
            this.children.splice(index, 1);
            symbol.setParent(undefined);
        }
    }
    getNestedSymbolsOfType(t) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            const childPromises = [];
            this.children.forEach((child) => {
                if (child instanceof t) {
                    result.push(child);
                }
                if (child instanceof ScopedSymbol) {
                    childPromises.push(child.getNestedSymbolsOfType(t));
                }
            });
            const childSymbols = yield Promise.all(childPromises);
            childSymbols.forEach((entry) => {
                result.push(...entry);
            });
            return result;
        });
    }
    getAllNestedSymbols(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            const childPromises = [];
            this.children.forEach((child) => {
                if (!name || child.name === name) {
                    result.push(child);
                }
                if (child instanceof ScopedSymbol) {
                    childPromises.push(child.getAllNestedSymbols(name));
                }
            });
            const childSymbols = yield Promise.all(childPromises);
            childSymbols.forEach((entry) => {
                result.push(...entry);
            });
            return result;
        });
    }
    getSymbolsOfType(t) {
        return new Promise((resolve) => {
            const result = [];
            this.children.forEach((child) => {
                if (child instanceof t) {
                    result.push(child);
                }
            });
            resolve(result);
        });
    }
    getAllSymbols(t, localOnly = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            for (const child of this.children) {
                if (child instanceof t) {
                    result.push(child);
                }
                if (child instanceof NamespaceSymbol) {
                    const childSymbols = yield child.getAllSymbols(t, true);
                    result.push(...childSymbols);
                }
            }
            if (!localOnly) {
                if (this.parent instanceof ScopedSymbol) {
                    const childSymbols = yield this.getAllSymbols(t, true);
                    result.push(...childSymbols);
                }
            }
            return result;
        });
    }
    resolve(name, localOnly = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                for (const child of this.children) {
                    if (child.name === name) {
                        resolve(child);
                        return;
                    }
                }
                if (!localOnly) {
                    if (this.parent instanceof ScopedSymbol) {
                        resolve(this.parent.resolve(name, false));
                        return;
                    }
                }
                resolve(undefined);
            });
        });
    }
    getTypedSymbols(localOnly = true) {
        const result = [];
        for (const child of this.children) {
            if (child instanceof TypedSymbol) {
                result.push(child);
            }
        }
        if (!localOnly) {
            if (this.parent instanceof ScopedSymbol) {
                const localList = this.parent.getTypedSymbols(true);
                result.push(...localList);
            }
        }
        return result;
    }
    getTypedSymbolNames(localOnly = true) {
        const result = [];
        for (const child of this.children) {
            if (child instanceof TypedSymbol) {
                result.push(child.name);
            }
        }
        if (!localOnly) {
            if (this.parent instanceof ScopedSymbol) {
                const localList = (this.parent).getTypedSymbolNames(true);
                result.push(...localList);
            }
        }
        return result;
    }
    get directScopes() {
        return this.getSymbolsOfType(ScopedSymbol);
    }
    symbolFromPath(path, separator = ".") {
        const elements = path.split(separator);
        let index = 0;
        if (elements[0] === this.name || elements[0].length === 0) {
            ++index;
        }
        let result = this;
        while (index < elements.length) {
            if (!(result instanceof ScopedSymbol)) {
                return undefined;
            }
            const child = result.children.find((candidate) => candidate.name === elements[index]);
            if (!child) {
                return undefined;
            }
            result = child;
            ++index;
        }
        return result;
    }
    indexOfChild(child) {
        return this.children.findIndex((value, index) => value === child);
    }
    nextSiblingOf(child) {
        const index = this.indexOfChild(child);
        if (index === -1 || index >= this.children.length - 1) {
            return;
        }
        return this.children[index + 1];
    }
    previousSiblingOf(child) {
        const index = this.indexOfChild(child);
        if (index < 1) {
            return;
        }
        return this.children[index - 1];
    }
    get firstChild() {
        if (this.children.length > 0) {
            return this.children[0];
        }
        return undefined;
    }
    get lastChild() {
        if (this.children.length > 0) {
            return this.children[this.children.length - 1];
        }
        return undefined;
    }
    nextOf(child) {
        if (!(child.parent instanceof ScopedSymbol)) {
            return;
        }
        if (child.parent !== this) {
            return child.parent.nextOf(child);
        }
        if (child instanceof ScopedSymbol && child.children.length > 0) {
            return child.children[0];
        }
        const sibling = this.nextSiblingOf(child);
        if (sibling) {
            return sibling;
        }
        return this.parent.nextOf(this);
    }
}
exports.ScopedSymbol = ScopedSymbol;
class NamespaceSymbol extends ScopedSymbol {
}
exports.NamespaceSymbol = NamespaceSymbol;
class BlockSymbol extends ScopedSymbol {
}
exports.BlockSymbol = BlockSymbol;
class VariableSymbol extends TypedSymbol {
    constructor(name, value, type) {
        super(name, type);
        this.value = value;
    }
}
exports.VariableSymbol = VariableSymbol;
class LiteralSymbol extends TypedSymbol {
    constructor(name, value, type) {
        super(name, type);
        this.value = value;
    }
}
exports.LiteralSymbol = LiteralSymbol;
class ParameterSymbol extends VariableSymbol {
}
exports.ParameterSymbol = ParameterSymbol;
class RoutineSymbol extends ScopedSymbol {
    constructor(name, returnType) {
        super(name);
        this.returnType = returnType;
    }
    getVariables(localOnly = true) {
        return this.getSymbolsOfType(VariableSymbol);
    }
    getParameters(localOnly = true) {
        return this.getSymbolsOfType(ParameterSymbol);
    }
}
exports.RoutineSymbol = RoutineSymbol;
var MethodFlags;
(function (MethodFlags) {
    MethodFlags[MethodFlags["None"] = 0] = "None";
    MethodFlags[MethodFlags["Virtual"] = 1] = "Virtual";
    MethodFlags[MethodFlags["Const"] = 2] = "Const";
    MethodFlags[MethodFlags["Overwritten"] = 4] = "Overwritten";
    MethodFlags[MethodFlags["SetterOrGetter"] = 8] = "SetterOrGetter";
    MethodFlags[MethodFlags["Explicit"] = 16] = "Explicit";
})(MethodFlags = exports.MethodFlags || (exports.MethodFlags = {}));
class MethodSymbol extends RoutineSymbol {
    constructor() {
        super(...arguments);
        this.methodFlags = MethodFlags.None;
        this.visibility = MemberVisibility.Invalid;
    }
}
exports.MethodSymbol = MethodSymbol;
class FieldSymbol extends VariableSymbol {
    constructor() {
        super(...arguments);
        this.visibility = MemberVisibility.Invalid;
    }
}
exports.FieldSymbol = FieldSymbol;
class ClassSymbol extends ScopedSymbol {
    constructor(name, referenceKind, ...superClass) {
        super(name);
        this.isStruct = false;
        this.superClasses = [];
        this.referenceKind = referenceKind;
        this.superClasses.push(...superClass);
    }
    get baseTypes() { return this.superClasses; }
    get kind() { return TypeKind.Class; }
    get reference() { return this.referenceKind; }
    getMethods(includeInherited = false) {
        return this.getSymbolsOfType(MethodSymbol);
    }
    getFields(includeInherited = false) {
        return this.getSymbolsOfType(FieldSymbol);
    }
}
exports.ClassSymbol = ClassSymbol;
class ArrayType extends Symbol {
    constructor(name, referenceKind, elemType, size = 0) {
        super(name);
        this.referenceKind = referenceKind;
        this.elementType = elemType;
        this.size = size;
    }
    get baseTypes() { return []; }
    get kind() { return TypeKind.Array; }
    get reference() { return this.referenceKind; }
}
exports.ArrayType = ArrayType;
class SymbolTable extends ScopedSymbol {
    constructor(name, options) {
        super(name);
        this.options = options;
        this.dependencies = new Set();
    }
    clear() {
        super.clear();
        this.dependencies.clear();
    }
    addDependencies(...tables) {
        tables.forEach((value, key) => {
            this.dependencies.add(value);
        });
    }
    removeDependency(table) {
        if (this.dependencies.has(table)) {
            this.dependencies.delete(table);
        }
    }
    get info() {
        return {
            dependencyCount: this.dependencies.size,
            symbolCount: this.children.length,
        };
    }
    addNewSymbolOfType(t, parent, ...args) {
        const result = new t(...args);
        if (!parent || parent === this) {
            this.addSymbol(result);
        }
        else {
            parent.addSymbol(result);
        }
        return result;
    }
    addNewNamespaceFromPath(parent, path, delimiter = ".") {
        return __awaiter(this, void 0, void 0, function* () {
            const parts = path.split(delimiter);
            let i = 0;
            let currentParent = (parent === undefined) ? this : parent;
            while (i < parts.length - 1) {
                let namespace = yield currentParent.resolve(parts[i], true);
                if (namespace === undefined) {
                    namespace = this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[i]);
                }
                currentParent = namespace;
                ++i;
            }
            return this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[parts.length - 1]);
        });
    }
    getAllSymbols(t, localOnly = false) {
        const _super = Object.create(null, {
            getAllSymbols: { get: () => super.getAllSymbols }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield _super.getAllSymbols.call(this, t, localOnly);
            if (!localOnly) {
                const dependencyResults = yield Promise.all([...this.dependencies].map((dependency) => (dependency.getAllSymbols(t, localOnly))));
                dependencyResults.forEach((value) => {
                    result.push(...value);
                });
            }
            return result;
        });
    }
    symbolWithContext(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const findRecursive = (symbol) => {
                if (symbol.context === context) {
                    return symbol;
                }
                if (symbol instanceof ScopedSymbol) {
                    for (const child of symbol.children) {
                        const result = findRecursive(child);
                        if (result) {
                            return result;
                        }
                    }
                }
            };
            let symbols = yield this.getAllSymbols(Symbol);
            for (const symbol of symbols) {
                const result = findRecursive(symbol);
                if (result) {
                    return result;
                }
            }
            for (const dependency of this.dependencies) {
                symbols = yield dependency.getAllSymbols(Symbol);
                for (const symbol of symbols) {
                    const result = findRecursive(symbol);
                    if (result) {
                        result;
                    }
                }
            }
        });
    }
    resolve(name, localOnly = false) {
        const _super = Object.create(null, {
            resolve: { get: () => super.resolve }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let result = yield _super.resolve.call(this, name, localOnly);
            if (!result && !localOnly) {
                for (const dependency of this.dependencies) {
                    result = yield dependency.resolve(name, false);
                    if (result) {
                        return result;
                    }
                }
            }
            return result;
        });
    }
}
exports.SymbolTable = SymbolTable;
//# sourceMappingURL=SymbolTable.js.map