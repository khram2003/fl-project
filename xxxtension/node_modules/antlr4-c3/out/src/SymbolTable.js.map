{"version":3,"file":"SymbolTable.js","sourceRoot":"","sources":["../../src/SymbolTable.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * This file is released under the MIT license.\n * Copyright (c) 2017, 2020, Mike Lischke\n *\n * See LICENSE file for more info.\n */\n\n/* eslint-disable max-classes-per-file */\n\nimport { ParseTree } from \"antlr4ts/tree/ParseTree\";\n\nexport class DuplicateSymbolError extends Error { }\n\nexport enum MemberVisibility {\n    Invalid = -1,\n    Public = 0,\n    Protected,\n    Private,\n    Library,\n}\n\nexport enum TypeKind {\n    Integer,\n    Float,\n    String,\n    Boolean,\n    Date,\n\n    Class,\n    Array,\n    Alias,\n}\n\nexport enum ReferenceKind {\n    Irrelevant,\n    Pointer,   // Default for most languages for dynamically allocated memory (\"Type*\" in C++).\n    Reference, // \"Type&\" in C++\n    Instance,  // \"Type\" as such and default for all value types.\n}\n\n// The root type interface. Used for typed symbols and type aliases.\nexport interface Type {\n    name: string;\n\n    // The super type of this type or empty if this is a fundamental type.\n    // Also used as the target type for type aliases.\n    baseTypes: Type[];\n    kind: TypeKind;\n    reference: ReferenceKind;\n}\n\nexport interface SymbolTableOptions {\n    allowDuplicateSymbols?: boolean;\n}\n\n// A single class for all fundamental types. They are distinguished via the kind field.\nexport class FundamentalType implements Type {\n    public static readonly integerType = new FundamentalType(\"int\", TypeKind.Integer, ReferenceKind.Instance);\n    public static readonly floatType = new FundamentalType(\"float\", TypeKind.Float, ReferenceKind.Instance);\n    public static readonly stringType = new FundamentalType(\"string\", TypeKind.String, ReferenceKind.Instance);\n    public static readonly boolType = new FundamentalType(\"bool\", TypeKind.Boolean, ReferenceKind.Instance);\n    public static readonly dateType = new FundamentalType(\"date\", TypeKind.Date, ReferenceKind.Instance);\n\n    public name: string;\n\n    private typeKind: TypeKind;\n    private referenceKind: ReferenceKind;\n\n    public constructor(name: string, typeKind: TypeKind, referenceKind: ReferenceKind) {\n        this.name = name;\n        this.typeKind = typeKind;\n        this.referenceKind = referenceKind;\n    }\n\n    public get baseTypes(): Type[] {\n        return [];\n    }\n\n    public get kind(): TypeKind {\n        return this.typeKind;\n    }\n\n    public get reference(): ReferenceKind {\n        return this.referenceKind;\n    }\n\n}\n\n// The root of the symbol table class hierarchy: a symbol can be any manageable entity (like a block), not only\n// things like variables or classes.\n// We are using a class hierarchy here, instead of an enum or similar, to allow for easy extension and certain\n// symbols can so provide additional APIs for simpler access to their sub elements, if needed.\nexport class Symbol {\n    public name = \"\";           // The name of the scope or empty if anonymous.\n    public context?: ParseTree; // Reference to the parse tree which contains this symbol.\n\n    private theParent?: Symbol;\n\n    public constructor(name = \"\") {\n        this.name = name;\n    }\n\n    /**\n     * The parent is usually a scoped symbol as only those can have children, but we allow\n     * any symbol here for special scenarios.\n     * This is rather an internal method and should rarely be used by external code.\n     *\n     * @param parent The new parent to use.\n     */\n    public setParent(parent: Symbol | undefined): void {\n        this.theParent = parent;\n    }\n\n    public get parent(): Symbol | undefined {\n        return this.theParent;\n    }\n\n    public get firstSibling(): Symbol {\n        if (this.theParent instanceof ScopedSymbol) {\n            return this.theParent.firstChild!;\n        }\n\n        return this;\n    }\n\n    /**\n     * @returns the symbol before this symbol in its scope.\n     */\n    public get previousSibling(): Symbol | undefined {\n        if (!(this.theParent instanceof ScopedSymbol)) {\n            return this;\n        }\n\n        return this.theParent.previousSiblingOf(this);\n    }\n\n    /**\n     * @returns the symbol following this symbol in its scope.\n     */\n    public get nextSibling(): Symbol | undefined {\n        if (!(this.theParent instanceof ScopedSymbol)) {\n            return this;\n        }\n\n        return this.theParent.nextSiblingOf(this);\n    }\n\n    public get lastSibling(): Symbol {\n        if (this.theParent instanceof ScopedSymbol) {\n            return this.theParent.lastChild!;\n        }\n\n        return this;\n    }\n\n    /**\n     * @returns the next symbol in definition order, regardless of the scope.\n     */\n    public get next(): Symbol | undefined {\n        if (this.theParent instanceof ScopedSymbol) {\n            return this.theParent.nextOf(this);\n        }\n\n        return undefined;\n    }\n\n    public removeFromParent(): void {\n        if (this.theParent instanceof ScopedSymbol) {\n            this.theParent.removeSymbol(this);\n            this.theParent = undefined;\n        }\n    }\n\n    /**\n     *\n     * @param name The name of the symbol to find.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     * @returns the first symbol with a given name, in the order of appearance in this scope\n     *          or any of the parent scopes (conditionally).\n     */\n    public async resolve(name: string, localOnly = false): Promise<Symbol | undefined> {\n        if (this.theParent instanceof ScopedSymbol) {\n            return this.theParent.resolve(name, localOnly);\n        }\n\n        return Promise.resolve(undefined);\n    }\n\n    /**\n     * @returns the outermost entity (below the symbol table) that holds us.\n     */\n    public get root(): Symbol | undefined {\n        let run = this.theParent;\n        while (run) {\n            if (!run.theParent || (run.theParent instanceof SymbolTable)) {\n                return run;\n            }\n            run = run.theParent;\n        }\n\n        return run;\n    }\n\n    /**\n     * @returns the symbol table we belong too or undefined if we are not yet assigned.\n     */\n    public get symbolTable(): SymbolTable | undefined {\n        if (this instanceof SymbolTable) {\n            return this;\n        }\n\n        let run = this.theParent;\n        while (run) {\n            if (run instanceof SymbolTable) { return run; }\n            run = run.theParent;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @param t The type of objects to return.\n     * @returns the next enclosing parent of the given type.\n     */\n    public getParentOfType<T extends Symbol>(t: new (...args: any[]) => T): T | undefined {\n        let run = this.theParent;\n        while (run) {\n            if (run instanceof t) { return run; }\n            run = run.theParent;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @returns the list of symbols from this one up to root.\n     */\n    public get symbolPath(): Symbol[] {\n        const result: Symbol[] = [];\n\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let run: Symbol = this;\n        while (run) {\n            result.push(run);\n            if (!run.theParent) { break; }\n            run = run.theParent;\n        }\n\n        return result;\n    }\n\n    /**\n     * Creates a qualified identifier from this symbol and its parent.\n     * If `full` is true then all parents are traversed in addition to this instance.\n     *\n     * @param separator The string to be used between the parts.\n     * @param full A flag indicating if the full path is to be returned.\n     * @param includeAnonymous Use a special string for empty scope names.\n     * @returns the constructed qualified identifier.\n     */\n    public qualifiedName(separator = \".\", full = false, includeAnonymous = false): string {\n        if (!includeAnonymous && this.name.length === 0) {\n            return \"\";\n        }\n\n        let result: string = this.name.length === 0 ? \"<anonymous>\" : this.name;\n        let run = this.theParent;\n        while (run) {\n            if (includeAnonymous || run.name.length > 0) {\n                result = (run.name.length === 0 ? \"<anonymous>\" : run.name) + separator + result;\n            }\n\n            if (!full || !run.theParent) {\n                break;\n            }\n            run = run.theParent;\n        }\n\n        return result;\n    }\n\n}\n\n// A symbol with an attached type (variables, fields etc.).\nexport class TypedSymbol extends Symbol {\n    public type: Type | undefined;\n\n    public constructor(name: string, type?: Type) {\n        super(name);\n        this.type = type;\n    }\n}\n\n// An alias for another type.\nexport class TypeAlias extends Symbol implements Type {\n    public get baseTypes(): Type[] { return [this.targetType]; }\n    public get kind(): TypeKind { return TypeKind.Alias; }\n    public get reference(): ReferenceKind { return ReferenceKind.Irrelevant; }\n\n    private targetType: Type;\n\n    public constructor(name: string, target: Type) {\n        super(name);\n        this.targetType = target;\n    }\n}\n\n// A symbol with a scope (so it can have child symbols).\nexport class ScopedSymbol extends Symbol {\n\n    private _children: Symbol[] = []; // All child symbols in definition order.\n\n    public constructor(name = \"\") {\n        super(name);\n    }\n\n    public get children(): Symbol[] {\n        // eslint-disable-next-line no-underscore-dangle\n        return this._children;\n    }\n\n    public clear(): void {\n        // eslint-disable-next-line no-underscore-dangle\n        this._children = [];\n    }\n\n    /**\n     * Adds the given symbol to this scope. If it belongs already to a different scope\n     * it is removed from that before adding it here.\n     *\n     * @param symbol The symbol to add as a child.\n     */\n    public addSymbol(symbol: Symbol): void {\n        symbol.removeFromParent();\n\n        // Check for duplicates first.\n        const symbolTable = this.symbolTable;\n        if (!symbolTable || !symbolTable.options.allowDuplicateSymbols) {\n            this.children.forEach((child) => {\n                if (child === symbol || (symbol.name.length > 0 && child.name === symbol.name)) {\n                    let name = symbol.name;\n                    if (name.length === 0) {\n                        name = \"<anonymous>\";\n                    }\n\n                    throw new DuplicateSymbolError(\"Attempt to add duplicate symbol '\" + name + \"'\");\n                }\n            });\n        }\n\n        this.children.push(symbol);\n        symbol.setParent(this);\n    }\n\n    public removeSymbol(symbol: Symbol): void {\n        const index = this.children.indexOf(symbol);\n        if (index > -1) {\n            this.children.splice(index, 1);\n            symbol.setParent(undefined);\n        }\n    }\n\n    /**\n     * @param t The type of of the objects to return.\n     * @returns A promise resolving to all (nested) children of the given type.\n     */\n    public async getNestedSymbolsOfType<T extends Symbol>(t: new (...args: any[]) => T): Promise<T[]> {\n        const result: T[] = [];\n\n        const childPromises: Array<Promise<T[]>> = [];\n        this.children.forEach((child) => {\n            if (child instanceof t) {\n                result.push(child);\n            }\n\n            if (child instanceof ScopedSymbol) {\n                childPromises.push(child.getNestedSymbolsOfType(t));\n            }\n        });\n        const childSymbols = await Promise.all(childPromises);\n        childSymbols.forEach((entry) => {\n            result.push(...entry);\n        });\n\n        return result;\n    }\n\n    /**\n     * @param name If given only returns symbols with that name.\n     * @returns A promise resolving to symbols from this and all nested scopes in the order they were defined.\n     */\n    public async getAllNestedSymbols(name?: string): Promise<Symbol[]> {\n        const result: Symbol[] = [];\n\n        const childPromises: Array<Promise<Symbol[]>> = [];\n        this.children.forEach((child) => {\n            if (!name || child.name === name) {\n                result.push(child);\n            }\n\n            if (child instanceof ScopedSymbol) {\n                childPromises.push(child.getAllNestedSymbols(name));\n            }\n        });\n        const childSymbols = await Promise.all(childPromises);\n        childSymbols.forEach((entry) => {\n            result.push(...entry);\n        });\n\n        return result;\n    }\n\n    /**\n     * @param t The type of of the objects to return.\n     * @returns A promise resolving to direct children of a given type.\n     */\n    public getSymbolsOfType<T extends Symbol>(t: new (...args: any[]) => T): Promise<T[]> {\n        return new Promise((resolve) => {\n            const result: T[] = [];\n            this.children.forEach((child) => {\n                if (child instanceof t) {\n                    result.push(child);\n                }\n            });\n\n            resolve(result);\n        });\n    }\n\n    /**\n     * TODO: add optional position dependency (only symbols defined before a given caret pos are viable).\n     *\n     * @param t The type of the objects to return.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     * @returns A promise resolving to all symbols of the the given type, accessible from this scope (if localOnly is\n     *          false), within the owning symbol table.\n     */\n    public async getAllSymbols<T extends Symbol>(t: new (...args: any[]) => T,\n        localOnly = false): Promise<T[]> {\n        const result: T[] = [];\n\n        // Special handling for namespaces, which act like grouping symbols in this scope,\n        // so we show them as available in this scope.\n        for (const child of this.children) {\n            if (child instanceof t) {\n                result.push(child);\n            }\n\n            if (child instanceof NamespaceSymbol) {\n                const childSymbols = await child.getAllSymbols(t, true);\n                result.push(...childSymbols);\n            }\n        }\n\n        if (!localOnly) {\n            if (this.parent instanceof ScopedSymbol) {\n                const childSymbols = await this.getAllSymbols(t, true);\n                result.push(...childSymbols);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @param name The name of the symbol to resolve.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     * @returns the first symbol with a given name, in the order of appearance in this scope\n     *          or any of the parent scopes (conditionally).\n     */\n    public async resolve(name: string, localOnly = false): Promise<Symbol | undefined> {\n        return new Promise((resolve, reject) => {\n            for (const child of this.children) {\n                if (child.name === name) {\n                    resolve(child);\n\n                    return;\n                }\n            }\n\n            // Nothing found locally. Let the parent continue.\n            if (!localOnly) {\n                if (this.parent instanceof ScopedSymbol) {\n                    resolve(this.parent.resolve(name, false));\n\n                    return;\n                }\n            }\n\n            resolve(undefined);\n        });\n    }\n\n    /**\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     * @returns all accessible symbols that have a type assigned.\n     */\n    public getTypedSymbols(localOnly = true): TypedSymbol[] {\n        const result: TypedSymbol[] = [];\n\n        for (const child of this.children) {\n            if (child instanceof TypedSymbol) {\n                result.push(child);\n            }\n        }\n\n        if (!localOnly) {\n            if (this.parent instanceof ScopedSymbol) {\n                const localList = this.parent.getTypedSymbols(true);\n                result.push(...localList);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * The names of all accessible symbols with a type.\n     *\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     * @returns A list of names.\n     */\n    public getTypedSymbolNames(localOnly = true): string[] {\n        const result: string[] = [];\n        for (const child of this.children) {\n            if (child instanceof TypedSymbol) {\n                result.push(child.name);\n            }\n        }\n\n        if (!localOnly) {\n            if (this.parent instanceof ScopedSymbol) {\n                const localList = (this.parent).getTypedSymbolNames(true);\n                result.push(...localList);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @returns A promise resolving to all direct child symbols with a scope (e.g. classes in a module).\n     */\n    public get directScopes(): Promise<ScopedSymbol[]> {\n        return this.getSymbolsOfType(ScopedSymbol);\n    }\n\n    /**\n     * @returns the symbol located at the given path through the symbol hierarchy.\n     * @param path The path consisting of symbol names separator by `separator`.\n     * @param separator The character to separate path segments.\n     */\n    public symbolFromPath(path: string, separator = \".\"): Symbol | undefined {\n        const elements = path.split(separator);\n        let index = 0;\n        if (elements[0] === this.name || elements[0].length === 0) {\n            ++index;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let result: Symbol = this;\n        while (index < elements.length) {\n            if (!(result instanceof ScopedSymbol)) {\n                return undefined;\n            }\n\n            // eslint-disable-next-line no-loop-func\n            const child = result.children.find((candidate) => candidate.name === elements[index]);\n            if (!child) {\n                return undefined;\n            }\n\n            result = child;\n            ++index;\n        }\n\n        return result;\n    }\n\n    /**\n     * @param child The child to search for.\n     * @returns the index of the given child symbol in the child list or -1 if it couldn't be found.\n     */\n    public indexOfChild(child: Symbol): number {\n        return this.children.findIndex((value: Symbol, index: number) => value === child);\n    }\n\n    /**\n     * @param child The reference node.\n     * @returns the sibling symbol after the given child symbol, if one exists.\n     */\n    public nextSiblingOf(child: Symbol): Symbol | undefined {\n        const index = this.indexOfChild(child);\n        if (index === -1 || index >= this.children.length - 1) {\n            return;\n        }\n\n        return this.children[index + 1];\n    }\n\n    /**\n     * @param child The reference node.\n     * @returns the sibling symbol before the given child symbol, if one exists.\n     */\n    public previousSiblingOf(child: Symbol): Symbol | undefined {\n        const index = this.indexOfChild(child);\n        if (index < 1) {\n            return;\n        }\n\n        return this.children[index - 1];\n    }\n\n    public get firstChild(): Symbol | undefined {\n        if (this.children.length > 0) {\n            return this.children[0];\n        }\n\n        return undefined;\n    }\n\n    public get lastChild(): Symbol | undefined {\n        if (this.children.length > 0) {\n            return this.children[this.children.length - 1];\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @param child The reference node.\n     * @returns the next symbol in definition order, regardless of the scope.\n     */\n    public nextOf(child: Symbol): Symbol | undefined {\n        if (!(child.parent instanceof ScopedSymbol)) {\n            return;\n        }\n\n        if (child.parent !== this) {\n            return child.parent.nextOf(child);\n        }\n\n        if (child instanceof ScopedSymbol && child.children.length > 0) {\n            return child.children[0];\n        }\n\n        const sibling = this.nextSiblingOf(child);\n        if (sibling) {\n            return sibling;\n        }\n\n        return (this.parent as ScopedSymbol).nextOf(this);\n    }\n}\n\nexport class NamespaceSymbol extends ScopedSymbol {\n}\n\nexport class BlockSymbol extends ScopedSymbol {\n}\n\nexport class VariableSymbol extends TypedSymbol {\n\n    public value: any;\n\n    public constructor(name: string, value: any, type?: Type) {\n        super(name, type);\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.value = value;\n    }\n}\n\nexport class LiteralSymbol extends TypedSymbol {\n    public readonly value: any;\n\n    public constructor(name: string, value: any, type?: Type) {\n        super(name, type);\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.value = value;\n    }\n}\n\nexport class ParameterSymbol extends VariableSymbol { }\n\n// A standalone function/procedure/rule.\nexport class RoutineSymbol extends ScopedSymbol {\n    private returnType?: Type; // Can be null if result is void.\n\n    public constructor(name: string, returnType: Type) {\n        super(name);\n        this.returnType = returnType;\n    }\n\n    public getVariables(localOnly = true): Promise<VariableSymbol[]> {\n        return this.getSymbolsOfType(VariableSymbol);\n    }\n\n    public getParameters(localOnly = true): Promise<ParameterSymbol[]> {\n        return this.getSymbolsOfType(ParameterSymbol);\n    }\n}\n\nexport enum MethodFlags {\n    None = 0,\n    Virtual = 1,\n    Const = 2,\n    Overwritten = 4,\n    SetterOrGetter = 8, // Distinguished by the return type.\n    Explicit = 16,      // Special flag used e.g. in C++ for explicit c-tors.\n}\n\n// A routine which belongs to a class or other outer container structure.\nexport class MethodSymbol extends RoutineSymbol {\n    public methodFlags = MethodFlags.None;\n    public visibility = MemberVisibility.Invalid;\n}\n\nexport class FieldSymbol extends VariableSymbol {\n    public visibility = MemberVisibility.Invalid;\n\n    public setter?: MethodSymbol;\n    public getter?: MethodSymbol;\n\n}\n\n// Classes and structs.\nexport class ClassSymbol extends ScopedSymbol implements Type {\n\n    public get baseTypes(): Type[] { return this.superClasses; }\n    public get kind(): TypeKind { return TypeKind.Class; }\n    public get reference(): ReferenceKind { return this.referenceKind; }\n\n    public isStruct = false;\n\n    /**\n     * Usually only one member, unless the language supports multiple inheritance.\n     */\n    public readonly superClasses: ClassSymbol[] = [];\n\n    private referenceKind: ReferenceKind;\n\n    public constructor(name: string, referenceKind: ReferenceKind, ...superClass: ClassSymbol[]) {\n        super(name);\n        this.referenceKind = referenceKind;\n        this.superClasses.push(...superClass); // Standard case: a single super class.\n    }\n\n    /**\n     * @param includeInherited Not used.\n     * @returns a list of all methods.\n     */\n    public getMethods(includeInherited = false): Promise<MethodSymbol[]> {\n        return this.getSymbolsOfType(MethodSymbol);\n    }\n\n    /**\n     * @param includeInherited Not used.\n     * @returns all fields.\n     */\n    public getFields(includeInherited = false): Promise<FieldSymbol[]> {\n        return this.getSymbolsOfType(FieldSymbol);\n    }\n\n}\n\nexport class ArrayType extends Symbol implements Type {\n\n    public get baseTypes(): Type[] { return []; }\n    public get kind(): TypeKind { return TypeKind.Array; }\n    public get reference(): ReferenceKind { return this.referenceKind; }\n\n    public readonly elementType: Type;\n    public readonly size: number; // > 0 if fixed length.\n\n    private referenceKind: ReferenceKind;\n\n    public constructor(name: string, referenceKind: ReferenceKind, elemType: Type, size = 0) {\n        super(name);\n        this.referenceKind = referenceKind;\n        this.elementType = elemType;\n        this.size = size;\n    }\n}\n\n// The main class managing all the symbols for a top level entity like a file, library or similar.\nexport class SymbolTable extends ScopedSymbol {\n    // Other symbol information available to this instance.\n    protected dependencies: Set<SymbolTable> = new Set();\n\n    public constructor(name: string, public readonly options: SymbolTableOptions) {\n        super(name);\n    }\n\n    public clear() {\n        super.clear();\n        this.dependencies.clear();\n    }\n\n    public addDependencies(...tables: SymbolTable[]) {\n        tables.forEach((value, key) => {\n            this.dependencies.add(value);\n        });\n    }\n\n    public removeDependency(table: SymbolTable) {\n        if (this.dependencies.has(table)) {\n            this.dependencies.delete(table);\n        }\n    }\n\n    /**\n     * @returns instance information, mostly relevant for unit testing.\n     */\n    public get info() {\n        return {\n            dependencyCount: this.dependencies.size,\n            symbolCount: this.children.length,\n        };\n    }\n\n    public addNewSymbolOfType<T extends Symbol>(t: new (...args: any[]) => T,\n        parent: ScopedSymbol | undefined, ...args: any[]): T {\n\n        const result = new t(...args);\n        if (!parent || parent === this) {\n            this.addSymbol(result);\n        } else {\n            parent.addSymbol(result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Adds a new namespace to the symbol table or the given parent. The path parameter specifies a single namespace\n     * name or a chain of namespaces (which can be e.g. \"outer.intermittent.inner.final\").\n     * If any of the parent namespaces is missing they are created implicitly. The final part must not exist however\n     * or you'll get a duplicate symbol error.\n     *\n     * @param parent The parent to add the namespace to.\n     * @param path The namespace path.\n     * @param delimiter The delimiter used in the path.\n     * @returns The new symbol.\n     */\n    public async addNewNamespaceFromPath(parent: ScopedSymbol | undefined, path: string,\n        delimiter = \".\"): Promise<NamespaceSymbol> {\n        const parts = path.split(delimiter);\n        let i = 0;\n        let currentParent = (parent === undefined) ? this : parent;\n        while (i < parts.length - 1) {\n            let namespace = await currentParent.resolve(parts[i], true) as NamespaceSymbol;\n            if (namespace === undefined) {\n                namespace = this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[i]);\n            }\n            currentParent = namespace;\n            ++i;\n        }\n\n        return this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[parts.length - 1]);\n    }\n\n    public async getAllSymbols<T extends Symbol>(t: new (...args: any[]) => T, localOnly = false): Promise<T[]> {\n        const result: T[] = await super.getAllSymbols(t, localOnly);\n\n        if (!localOnly) {\n            const dependencyResults = await Promise.all([...this.dependencies].map((dependency) => (\n                dependency.getAllSymbols(t, localOnly)\n            )));\n\n            dependencyResults.forEach((value) => {\n                result.push(...value);\n            });\n        }\n\n        return result;\n    }\n\n    /**\n     * Looks for a symbol which is connected with a given parse tree context.\n     *\n     * @param context The context to search for.\n     * @returns A promise resolving to the found symbol or undefined.\n     */\n    public async symbolWithContext(context: ParseTree): Promise<Symbol | undefined> {\n        /**\n         * Local function to find a symbol recursively.\n         *\n         * @param symbol The symbol to search through.\n         * @returns The symbol with the given context, if found.\n         */\n        const findRecursive = (symbol: Symbol): Symbol | undefined => {\n            if (symbol.context === context) {\n                return symbol;\n            }\n\n            if (symbol instanceof ScopedSymbol) {\n                for (const child of symbol.children) {\n                    const result = findRecursive(child);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n        };\n\n\n        let symbols = await this.getAllSymbols(Symbol);\n        for (const symbol of symbols) {\n            const result = findRecursive(symbol);\n            if (result) {\n                return result;\n            }\n        }\n\n        for (const dependency of this.dependencies) {\n            symbols = await dependency.getAllSymbols(Symbol);\n            for (const symbol of symbols) {\n                const result = findRecursive(symbol);\n                if (result) {\n                    result;\n                }\n            }\n        }\n    }\n\n    /**\n     * Resolves a name to a symbol.\n     *\n     * @param name The name of the symbol to find.\n     * @param localOnly A flag indicating if only this symbol table should be used or also its dependencies.\n     * @returns The found symbol or undefined.\n     */\n    public async resolve(name: string, localOnly = false): Promise<Symbol | undefined> {\n        let result = await super.resolve(name, localOnly);\n        if (!result && !localOnly) {\n            for (const dependency of this.dependencies) {\n                result = await dependency.resolve(name, false);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n\n        return result;\n    }\n\n}\n"]}